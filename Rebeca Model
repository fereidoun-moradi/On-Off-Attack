// honest user
reactiveclass User(5) {
    knownrebecs {
		Miner m; 
    }
    statevars {
    	int uId, ctrTx, totalTx; 
    }
    User(int myId, int tTx) { //Note: tTx for a honest user is digit < 10
    	uId = myId;
    	totalTx = tTx;
    	ctrTx = 0; // It begin from 1
    	self.generateTx();
    }
    msgsrv generateTx(){
    	if (ctrTx < totalTx) {
    			ctrTx = ctrTx + 1;
    			m.sendTx(uId, ctrTx); 
    			self.generateTx();
    		}
    }
}





// Malicious user
reactiveclass MalUser(5) {
    knownrebecs {
		MalMiner m; 
    }
    statevars {
		int uId, ctrTx, totalTx;
    }
    MalUser(int myId, int tTx) { //Note: tTx for a dishonest user is digit > 10
    	uId = myId;
    	totalTx = tTx;
    	ctrTx = 9; // It begin from 10
    	self.generateTx();
    }
    msgsrv generateTx(){
    	if (ctrTx < totalTx) {
    			ctrTx = ctrTx + 1;
    			m.sendTx(uId, ctrTx); 
    			self.generateTx();
    		}
    }
}

reactiveclass Manager(10) {
    knownrebecs {
		Miner m1;
		Miner m2;
		MalMiner m3;
    }
    statevars {
    	int random;
    }
    msgsrv selectRandomly(int ext){
    	// there are 3 miner so it choose a random value among them
    	if(ext == 0) {
    		random = ?(1,2,3);
    		if(random == 1){ m1.buildblk();}
    		if(random == 2){ m2.buildblk();}
    		if(random == 3){ m3.buildblk();}
    	}
    	if(ext == 1){
    		random = ?(2,3);
    		if(random == 2){ m2.buildblk();}
    		if(random == 3){ m3.buildblk();}
    	}
    	if(ext == 2){
    		random = ?(1,3);
    		if(random == 1){ m1.buildblk();}
    		if(random == 3){ m3.buildblk();}
    	}
    	if(ext == 3){
    		random = ?(1,2);
    		if(random == 1){ m1.buildblk();}
    		if(random == 2){ m2.buildblk();}
    	}
    }
 }


// honest miner
reactiveclass Miner(10) {
    knownrebecs {
		Miner m1;
		MalMiner m2;
		Manager mgr;
    }
    statevars {
		int mId;
		int [50][8]BC; // minerID, BlockID, utx1, tx1, utx2, tx2, utx3, tx3
		int [70][3]pendingPool;// pending pool of valid transactions
		int [5]trustRate; // It stores direct trust rate
		int [3]uidtx; // Block size is 3. It maintains tree trx for block generation
		int [3]tx;   //
		int ctrTrx; // It counts the number of valid transactions in pending pool
		int nBlk;   // It count the number of blocks that are grenerated by a Miner
		int blockId;
		int randomSelection;
		boolean send; 
		int k, j, p, h;
		boolean check;
		boolean go;
    }
    Miner(int myId) {
    	mId = myId;
    	blockId = 1;
    	nBlk = 1;
		k = 0;
		j = 0;
		ctrTrx = 0;
		p = 70;
		go = true;
		send = true;
		for (int l = 0; l < 5; l++) {
  				trustRate[l] = 0;
		}
		for (int l = 0; l < p; l++) {
  				pendingPool[l][0] = 0;
  				pendingPool[l][1] = 0;
  				pendingPool[l][2] = 0;
		}
		for (int l = 0; l < 50; l++) 
			for(int m = 0; m < 8; m++){
  				BC[l][m] = 0;
		}
		for (int l = 0; l < 3; l++){
			uidtx[l] = 0;
			tx[l] = 0;
			 
		}		
    }
    msgsrv sendTx(int utx, int idTx) {
    	// It checks if this trx was already validated and has been inserted to the pending pool
    	check = true;
    	for (int l = 0; l < p; l++)
  			if (pendingPool[l][0] == utx && pendingPool[l][1] == idTx) {
  				check = false; 
  				break;
  			}
  		// It checks if this trx was already has been inserted to BC	
		for (int l = 0; l <= k; l++) 
  			if ((BC[l][2] == utx && BC[l][3] == idTx) || (BC[l][4] == utx && BC[l][5] == idTx) || (BC[l][6] == utx && BC[l][7] == idTx)) {
  				check = false; 
  				break;
  			}	
		// It checks validation of transaction and then add it to the pending pool(e.g. user & trx must be under 10)
		if (check) {
    		if (idTx < 10) {
    			if (utx < 10) {
    				for (int l = 0; l < p; l++) 
  						if (pendingPool[l][0] == 0) {
  							pendingPool[l][0] = utx;
  							pendingPool[l][1] = idTx;
  							ctrTrx++;
  							m1.sendTx(utx, idTx);
  							m2.sendTx(utx, idTx);
  							if ((ctrTrx > 2) && (nBlk < 3) && (send == true)) {
  								nBlk ++; 
  								mgr.selectRandomly(0);
  								send = false;
  							} /*else mgr.selectRandomly(mId);*/
  							break;
  					}
    		    }
    	    }
    	}
    }
    msgsrv buildblk() {	
    		h = 0;
    		go = true;
    		for (int l = 0; l < p; l++) {
  				if (pendingPool[l][0] != 0 && pendingPool[l][2] != 999) {
  					for (int f = 0; f <= k; f++) {
  						if ((BC[f][2] == pendingPool[l][0] && BC[f][3] == pendingPool[l][1]) || (BC[f][4] == pendingPool[l][0] && BC[f][5] == pendingPool[l][1]) || (BC[f][6] == pendingPool[l][0] && BC[f][7] == pendingPool[l][1])) {
  							go = false; 
  							break;
  						}	
					}
					if(go) {
  						uidtx[h] =  pendingPool[l][0];
  						tx[h] = pendingPool[l][1];
  						pendingPool[l][2] = 999;
  						ctrTrx--;
  						h++;
  						if(h == 3) {break;}
  					}	
  				}
  			}
  			if (h == 3) {
  				//self.addtoBC(mId, blockId, uidtx[0], tx[0], uidtx[1], tx[1], uidtx[2], tx[2]);
  				BC[k][0] = mId;
				BC[k][1] = blockId;
				BC[k][2] = uidtx[0];
				BC[k][3] = tx[0];
				BC[k][4] = uidtx[1];
				BC[k][5] = tx[1];
				BC[k][6] = uidtx[2];
				BC[k][7] = tx[2];
  				m1.addtoBC(mId, blockId, uidtx[0], tx[0], uidtx[1], tx[1], uidtx[2], tx[2]);
  				m2.addtoBC(mId, blockId, uidtx[0], tx[0], uidtx[1], tx[1], uidtx[2], tx[2]);
  				blockId = blockId + 1;
				k = k + 1;
  			}
  			send = true;
    }
    msgsrv addtoBC(int mid, int blockid, int uidtx1, int tx1, int uidtx2, int tx2, int uidtx3, int tx3) {
		for (int l = 0; l < p; l++) {
  			if (pendingPool[l][0] == uidtx1 && pendingPool[l][1] == tx1 && pendingPool[l][2] != 999) {
  					pendingPool[l][2] = 999;
  					ctrTrx--;
  					break; 
  			}
  		} 
  		for (int l = 0; l < p; l++) {
  			if (pendingPool[l][0] == uidtx2 && pendingPool[l][1] == tx2 && pendingPool[l][2] != 999) {
  					pendingPool[l][2] = 999;
  					ctrTrx--;
  					break;
  			}
  		}	
  		for (int l = 0; l < p; l++) {
  			if (pendingPool[l][0] == uidtx3 && pendingPool[l][1] == tx3 && pendingPool[l][2] != 999) {
  					pendingPool[l][2] = 999;
  					ctrTrx--;
  					break;
  			}	
		} 		
    	if (trustRate[mid] == 0) {
    		if ((uidtx1 < 10) && (uidtx2 < 10) && (uidtx3 < 10)) {
    			if ((tx1 < 10) && (tx2 < 10) && (tx3 < 10)) {
					BC[k][0] = mid;
					BC[k][1] = blockid;
					BC[k][2] = uidtx1;
					BC[k][3] = tx1;
					BC[k][4] = uidtx2;
					BC[k][5] = tx2;
					BC[k][6] = uidtx3;
					BC[k][7] = tx3;
					trustRate[mid] = trustRate[mid] + 1;		
    			} else trustRate[mid] = trustRate[mid] - 1;
    		}
		k = k + 1;
		blockId = blockId + 1;
    	} else 
    			if (trustRate[mid] == 1) {
    				if ((uidtx1 < 10) && (uidtx2 < 10)) {
    					if ((tx1 < 10) && (tx2 < 10)) {
							BC[k][0] = mid;
							BC[k][1] = blockid;
							BC[k][2] = uidtx1;
							BC[k][3] = tx1;
							BC[k][4] = uidtx2;
							BC[k][5] = tx2;
							BC[k][6] = uidtx3;
							BC[k][7] = tx3;	
							trustRate[mid] = trustRate[mid] + 1;	
    					} else trustRate[mid] = trustRate[mid] - 1;
    				}
    				k = k + 1;
    				blockId = blockId + 1;
    			} else 
    	if (trustRate[mid] == 2) { 
    	  	randomSelection = ?(1,2,3);
    	  	if(randomSelection == 1) {	
    			if (uidtx1 < 10) {
    				if (tx1 < 10) {
						BC[k][0] = mid;
						BC[k][1] = blockid;
						BC[k][2] = uidtx1;
						BC[k][3] = tx1;
						BC[k][4] = uidtx2;
						BC[k][5] = tx2;
						BC[k][6] = uidtx3;
						BC[k][7] = tx3;	
						//trustRate[mid] = trustRate[mid] + 1;	
    				} else trustRate[mid] = trustRate[mid] - 1;
    			}
    		}	
    		if(randomSelection == 2) {
    		if (uidtx2 < 10) {
    				if (tx2 < 10) {
						BC[k][0] = mid;
						BC[k][1] = blockid;
						BC[k][2] = uidtx1;
						BC[k][3] = tx1;
						BC[k][4] = uidtx2;
						BC[k][5] = tx2;
						BC[k][6] = uidtx3;
						BC[k][7] = tx3;	
						//trustRate[mid] = trustRate[mid] + 1;	
    				} else trustRate[mid] = trustRate[mid] - 1;
    			}
    		}
    		if(randomSelection == 3){
    		if (uidtx3 < 10) {
    				if (tx3 < 10) {
						BC[k][0] = mid;
						BC[k][1] = blockid;
						BC[k][2] = uidtx1;
						BC[k][3] = tx1;
						BC[k][4] = uidtx2;
						BC[k][5] = tx2;
						BC[k][6] = uidtx3;
						BC[k][7] = tx3;	
						//trustRate[mid] = trustRate[mid] + 1;	
    				} else trustRate[mid] = trustRate[mid] - 1;
    			}
    		}	
    	k = k + 1;
    	blockId = blockId + 1;
        }
        send = true;
        if (blockId % 2 == 0) {
       		nBlk = 1;
       		}
       	if ((ctrTrx > 2) && (nBlk < 3)) { nBlk ++; self.buildblk();}
       	/*if ((ctrTrx > 2) && (nBlk < 3) && (send == true)) {
  			nBlk ++; 
  			mgr.selectRandomly(0);
  			send = false;
  			} else mgr.selectRandomly(mId);*/
       	
       }	
}



// Malicious Miner 
reactiveclass MalMiner(10) {
    knownrebecs {
		Miner m1;
		Miner m2;
		Manager mgr;
		
    }
    statevars {
		int mId;
		int [20][8]BC; // minerID, BlockkID, utx1, tx1, utx2, tx2, utx3, tx3
		int [30][3]pendingPool;// pending pool of valid transactions
		int p;
		int delay;
		int blockId;
		int k;
		int j;
		int [5]trustRate;
		boolean check;
		boolean send;
		int ctrTrx;
		int [3]uidtx;
		int [3]tx;
		int h;
		boolean go;
		int nBlk;
		int ctrMTrx;
    }
    MalMiner(int myId) {
    	mId = myId;
    	blockId = 1;
		k = 0;
		j = 0;
		ctrTrx = 0;
		p = 30;
		go = true;
		send = true;
		nBlk = 1;
		ctrMTrx = 0;
		trustRate[0] = 0;
		trustRate[1] = 0;
		trustRate[2] = 0;
		trustRate[3] = 0;
		trustRate[4] = 0;
		for (int l = 0; l < p; l++) {
  				pendingPool[l][0] = 0;
  				pendingPool[l][1] = 0;
  				pendingPool[l][2] = 0;
		}
		for (int l = 0; l < 20; l++) {
  				BC[l][0] = 0;
  				BC[l][1] = 0;
  				BC[l][2] = 0;
  				BC[l][3] = 0;
  				BC[l][4] = 0;
  				BC[l][5] = 0;
  				BC[l][6] = 0;
  				BC[l][7] = 0;
		}
		for (int l = 0; l < 3; l++){
			uidtx[l] = 0;
			tx[l] = 0;
			 
		}
		
    }
    msgsrv sendTx(int utx, int idTx) {
    	// It checks if this trx was already validated and inserted to the pending pool
    	check = true;
    	for (int l = 0; l < p; l++) {
  			if (pendingPool[l][0] == utx && pendingPool[l][1] == idTx) {
  				check = false; 
  				break;
  			}	
		}
		for (int l = 0; l <= k; l++) {
  			if ((BC[l][2] == utx && BC[l][3] == idTx) || (BC[l][4] == utx && BC[l][5] == idTx) || (BC[l][6] == utx && BC[l][7] == idTx)) {
  				check = false; 
  				break;
  			}	
		}
		// It checks validation of transaction and then add it to the pool(e.g. user & trx must be under 10)
		if (check) {
    		if (idTx < 10) {
    			if (utx < 10) {
    				for (int l = 0; l < p; l++) {
  						if (pendingPool[l][0] == 0) {
  							pendingPool[l][0] = utx;
  							pendingPool[l][1] = idTx;
  							ctrTrx++;
  							m1.sendTx(utx, idTx);
  							m2.sendTx(utx, idTx);
  							//if ((ctrTrx > 2) && (nBlk < 3)) { nBlk ++; self.buildblk();}
  							if ((ctrTrx > 2) && (nBlk < 3) && (send == true)) {
  								nBlk ++; 
  								//self.buildblk();
  								mgr.selectRandomly(0);
  								send = false;
  							} /*else mgr.selectRandomly(mId);*/
  							break;
  						}
  					}
    		    }
    	    } else 
    		     for (int l = 0; l < p; l++) {
  						if (pendingPool[l][0] == 0) {
  							pendingPool[l][0] = utx;
  							pendingPool[l][1] = idTx;
  							pendingPool[l][2] = 111;
  							ctrMTrx++;
  							if (((ctrTrx + ctrMTrx) > 2) && (nBlk < 3) && ( blockId == 5 )) { nBlk ++; self.buildblk();}
  							break;
  						}
  			  	 }
    	}
    }
    msgsrv buildblk() {	
    		h = 0;
    		go = true;
    	if (blockId == 5) {
    		for (int l = 0; l < p; l++) {
  				if (pendingPool[l][0] != 0 && pendingPool[l][2] != 999) {
  					for (int f = 0; f <= k; f++) {
  						if ((BC[f][2] == pendingPool[l][0] && BC[f][3] == pendingPool[l][1]) || (BC[f][4] == pendingPool[l][0] && BC[f][5] == pendingPool[l][1]) || (BC[f][6] == pendingPool[l][0] && BC[f][7] == pendingPool[l][1])) {
  							go = false; 
  							break;
  						}	
					}
					if(go) {
  						uidtx[h] =  pendingPool[l][0];
  						tx[h] = pendingPool[l][1];
  						pendingPool[l][2] = 999;
  						ctrTrx--;
  						h++;
  						if(h == 3) {break;}
  					}	
  				}
  			}
  		} else
  			for (int l = 0; l < p; l++) {
  				if (pendingPool[l][0] != 0 && pendingPool[l][2] != 999 && pendingPool[l][2] != 111) {
  					for (int f = 0; f <= k; f++) {
  						if ((BC[f][2] == pendingPool[l][0] && BC[f][3] == pendingPool[l][1]) || (BC[f][4] == pendingPool[l][0] && BC[f][5] == pendingPool[l][1]) || (BC[f][6] == pendingPool[l][0] && BC[f][7] == pendingPool[l][1])) {
  							go = false; 
  							break;
  						}	
					}
					if(go) {
  						uidtx[h] =  pendingPool[l][0];
  						tx[h] = pendingPool[l][1];
  						pendingPool[l][2] = 999;
  						ctrTrx--;
  						h++;
  						if(h == 3) {break;}
  					}	
  				}
  			}
  			
  			if (h == 3) {
  				//self.addtoBC(mId, blockId, uidtx[0], tx[0], uidtx[1], tx[1], uidtx[2], tx[2]);
  				BC[k][0] = mId;
				BC[k][1] = blockId;
				BC[k][2] = uidtx[0];
				BC[k][3] = tx[0];
				BC[k][4] = uidtx[1];
				BC[k][5] = tx[1];
				BC[k][6] = uidtx[2];
				BC[k][7] = tx[2];
  				m1.addtoBC(mId, blockId, uidtx[0], tx[0], uidtx[1], tx[1], uidtx[2], tx[2]);
  				m2.addtoBC(mId, blockId, uidtx[0], tx[0], uidtx[1], tx[1], uidtx[2], tx[2]);
  				blockId = blockId + 1;
				k = k + 1;
  			}
  			send = true;
    }
    msgsrv addtoBC(int mid, int blockid, int uidtx1, int tx1, int uidtx2, int tx2, int uidtx3, int tx3) {
		for (int l = 0; l < p; l++) {
  			if (pendingPool[l][0] == uidtx1 && pendingPool[l][1] == tx1 && pendingPool[l][2] != 999) {
  					pendingPool[l][2] = 999;
  					ctrTrx--;
  					break; 
  			}
  		} 
  		for (int l = 0; l < p; l++) {
  			if (pendingPool[l][0] == uidtx2 && pendingPool[l][1] == tx2 && pendingPool[l][2] != 999) {
  					pendingPool[l][2] = 999;
  					ctrTrx--;
  					break;
  			}
  		}	
  		for (int l = 0; l < p; l++) {
  			if (pendingPool[l][0] == uidtx3 && pendingPool[l][1] == tx3 && pendingPool[l][2] != 999) {
  					pendingPool[l][2] = 999;
  					ctrTrx--;
  					break;
  			}	
		} 		
    	if (trustRate[mid] == 0) {
    		if ((uidtx1 < 10) && (uidtx2 < 10) && (uidtx3 < 10)) {
    			if ((tx1 < 10) && (tx2 < 10) && (tx3 < 10)) {
					BC[k][0] = mid;
					BC[k][1] = blockid;
					BC[k][2] = uidtx1;
					BC[k][3] = tx1;
					BC[k][4] = uidtx2;
					BC[k][5] = tx2;
					BC[k][6] = uidtx3;
					BC[k][7] = tx3;
					trustRate[mid] = trustRate[mid] + 1;		
    			} else trustRate[mid] = trustRate[mid] - 1;
    		}
		k = k + 1;
		blockId = blockId + 1;
    	} else 
    			if (trustRate[mid] == 1) {
    				if ((uidtx2 < 10) && (uidtx3 < 10)) {
    					if ((tx2 < 10) && (tx3 < 10)) {
							BC[k][0] = mid;
							BC[k][1] = blockid;
							BC[k][2] = uidtx1;
							BC[k][3] = tx1;
							BC[k][4] = uidtx2;
							BC[k][5] = tx2;
							BC[k][6] = uidtx3;
							BC[k][7] = tx3;	
							trustRate[mid] = trustRate[mid] + 1;	
    					} else trustRate[mid] = trustRate[mid] - 1;
    				}
    				k = k + 1;
    				blockId = blockId + 1;
    			} else 
    	if (trustRate[mid] == 2) {  		
    		if (uidtx2 < 10) {
    			if (tx2 < 10) {
					BC[k][0] = mid;
					BC[k][1] = blockid;
					BC[k][2] = uidtx1;
					BC[k][3] = tx1;
					BC[k][4] = uidtx2;
					BC[k][5] = tx2;
					BC[k][6] = uidtx3;
					BC[k][7] = tx3;	
					//trustRate[mid] = trustRate[mid] + 1;	
    			} else trustRate[mid] = trustRate[mid] - 1;
    		}
    	k = k + 1;
    	blockId = blockId + 1;
        }
        send = true;
        if (blockId % 2 == 0) {
       		nBlk = 1;
       		}
       	if ((ctrTrx > 2) && (nBlk < 3)) { nBlk ++; self.buildblk();;}
       	/*if ((ctrTrx > 2) && (nBlk < 3) && (send == true)) {
  			nBlk ++; 
  			mgr.selectRandomly(0);
  			send = false;
  			} else mgr.selectRandomly(mId);*/
       }	
}  
main {
	User u1 (ma): (1,8);
	User u2 (mb): (2,9);
	//User u3 (mc): (3,5); // This aspect is commented to have smalest model
	MalUser u3 (md): (3,10);
	Miner ma(mb,md,man):(1);
	Miner mb(ma,md,man):(2);
	//Miner mc(mb,md):(3); // This aspect is commented to have smalest model
	MalMiner md(ma,mb,man):(3);
	Manager man(ma, mb, md):();
}
    
